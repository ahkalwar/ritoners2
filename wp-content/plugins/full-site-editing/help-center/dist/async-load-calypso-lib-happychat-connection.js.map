{"version":3,"file":"async-load-calypso-lib-happychat-connection.js","mappings":"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","sources":["webpack://EditingToolkit/../../client/lib/happychat/connection.js"],"sourcesContent":["import debugFactory from 'debug';\nimport IO from 'socket.io-client';\nimport {\n\treceiveAccept,\n\treceiveConnect,\n\treceiveDisconnect,\n\treceiveError,\n\treceiveInit,\n\treceiveLocalizedSupport,\n\treceiveMessage,\n\treceiveMessageOptimistic,\n\treceiveMessageUpdate,\n\treceiveReconnecting,\n\treceiveStatus,\n\treceiveToken,\n\treceiveUnauthorized,\n\trequestTranscript,\n} from 'calypso/state/happychat/connection/actions';\n\nconst debug = debugFactory( 'calypso:happychat:connection' );\n\nconst buildConnection = ( socket ) =>\n\ttypeof socket === 'string'\n\t\t? new IO( socket, {\n\t\t\t\t// force websocket connection since we no longer have sticky connections server side.\n\t\t\t\ttransports: [ 'websocket' ],\n\t\t  } ) // If socket is an URL, connect to server.\n\t\t: socket; // If socket is not an url, use it directly. Useful for testing.\n\nclass Connection {\n\t/**\n\t * Init the SockeIO connection: check user authorization and bind socket events\n\t *\n\t * @param  { Function } dispatch Redux dispatch function\n\t * @param  { Promise } auth Authentication promise, will return the user info upon fulfillment\n\t * @returns { Promise } Fulfilled (returns the opened socket)\n\t *                   \t or rejected (returns an error message)\n\t */\n\tinit( dispatch, auth ) {\n\t\tif ( this.openSocket ) {\n\t\t\tdebug( 'socket is already connected' );\n\t\t\treturn this.openSocket;\n\t\t}\n\t\tthis.dispatch = dispatch;\n\n\t\tthis.openSocket = new Promise( ( resolve, reject ) => {\n\t\t\tauth\n\t\t\t\t.then( ( { url, user: { signer_user_id, jwt, locale, groups, skills, geoLocation } } ) => {\n\t\t\t\t\tconst socket = buildConnection( url );\n\n\t\t\t\t\tsocket\n\t\t\t\t\t\t.once( 'connect', () => dispatch( receiveConnect() ) )\n\t\t\t\t\t\t.on( 'token', ( handler ) => {\n\t\t\t\t\t\t\tdispatch( receiveToken() );\n\t\t\t\t\t\t\thandler( { signer_user_id, jwt, locale, groups, skills } );\n\t\t\t\t\t\t} )\n\t\t\t\t\t\t.on( 'init', () => {\n\t\t\t\t\t\t\tdispatch( receiveInit( { signer_user_id, locale, groups, skills, geoLocation } ) );\n\t\t\t\t\t\t\tdispatch( requestTranscript() );\n\t\t\t\t\t\t\tresolve( socket );\n\t\t\t\t\t\t} )\n\t\t\t\t\t\t.on( 'unauthorized', () => {\n\t\t\t\t\t\t\tsocket.close();\n\t\t\t\t\t\t\tdispatch( receiveUnauthorized( 'User is not authorized' ) );\n\t\t\t\t\t\t\treject( 'user is not authorized' );\n\t\t\t\t\t\t} )\n\t\t\t\t\t\t.on( 'disconnect', ( reason ) => dispatch( receiveDisconnect( reason ) ) )\n\t\t\t\t\t\t.on( 'reconnecting', () => dispatch( receiveReconnecting() ) )\n\t\t\t\t\t\t.on( 'status', ( status ) => dispatch( receiveStatus( status ) ) )\n\t\t\t\t\t\t.on( 'accept', ( accept ) => dispatch( receiveAccept( accept ) ) )\n\t\t\t\t\t\t.on( 'localized-support', ( accept ) => dispatch( receiveLocalizedSupport( accept ) ) )\n\t\t\t\t\t\t.on( 'message', ( message ) => dispatch( receiveMessage( message ) ) )\n\t\t\t\t\t\t.on( 'message.optimistic', ( message ) =>\n\t\t\t\t\t\t\tdispatch( receiveMessageOptimistic( message ) )\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.on( 'message.update', ( message ) => dispatch( receiveMessageUpdate( message ) ) )\n\t\t\t\t\t\t.on( 'reconnect_attempt', () => {\n\t\t\t\t\t\t\tsocket.io.opts.transports = [ 'polling', 'websocket' ];\n\t\t\t\t\t\t} );\n\t\t\t\t} )\n\t\t\t\t.catch( ( e ) => reject( e ) );\n\t\t} );\n\n\t\treturn this.openSocket;\n\t}\n\n\t/**\n\t * Given a Redux action, emits a SocketIO event.\n\t *\n\t * @param  {object} action A Redux action with props\n\t *                    {\n\t *                  \t\tevent: SocketIO event name,\n\t *                  \t  payload: contents to be sent,\n\t *                  \t  error: message to be shown should the event fails to be sent,\n\t *                  \t}\n\t * @returns { Promise } Fulfilled (returns nothing)\n\t *                     or rejected (returns an error message)\n\t */\n\tsend( action ) {\n\t\tif ( ! this.openSocket ) {\n\t\t\treturn;\n\t\t}\n\t\treturn this.openSocket.then(\n\t\t\t( socket ) => socket.emit( action.event, action.payload ),\n\t\t\t( e ) => {\n\t\t\t\tthis.dispatch( receiveError( 'failed to send ' + action.event + ': ' + e ) );\n\t\t\t\t// so we can relay the error message, for testing purposes\n\t\t\t\treturn Promise.reject( e );\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t *\n\t * Given a Redux action and a timeout, emits a SocketIO event that request\n\t * some info to the Happychat server.\n\t *\n\t * The request can have three states, and will dispatch an action accordingly:\n\t *\n\t * - request was succesful: would dispatch action.callback\n\t * - request was unsucessful: would dispatch receiveError\n\t *\n\t * @param  {object} action A Redux action with props\n\t *                  \t{\n\t *                  \t\tevent: SocketIO event name,\n\t *                  \t\tpayload: contents to be sent,\n\t *                  \t\tcallback: a Redux action creator\n\t *                  \t}\n\t * @param  {number} timeout How long (in milliseconds) has the server to respond\n\t * @returns { Promise } Fulfilled (returns the transcript response)\n\t *                     or rejected (returns an error message)\n\t */\n\trequest( action, timeout ) {\n\t\tif ( ! this.openSocket ) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.openSocket.then(\n\t\t\t( socket ) => {\n\t\t\t\tconst promiseRace = Promise.race( [\n\t\t\t\t\tnew Promise( ( resolve, reject ) => {\n\t\t\t\t\t\tsocket.emit( action.event, action.payload, ( e, result ) => {\n\t\t\t\t\t\t\tif ( e ) {\n\t\t\t\t\t\t\t\treturn reject( new Error( e ) ); // request failed\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn resolve( result ); // request succesful\n\t\t\t\t\t\t} );\n\t\t\t\t\t} ),\n\t\t\t\t\tnew Promise( ( resolve, reject ) =>\n\t\t\t\t\t\tsetTimeout( () => {\n\t\t\t\t\t\t\treturn reject( new Error( 'timeout' ) ); // request timeout\n\t\t\t\t\t\t}, timeout )\n\t\t\t\t\t),\n\t\t\t\t] );\n\n\t\t\t\t// dispatch the request state upon promise race resolution\n\t\t\t\tpromiseRace.then(\n\t\t\t\t\t( result ) => this.dispatch( action.callback( result ) ),\n\t\t\t\t\t( e ) => {\n\t\t\t\t\t\tif ( e.message !== 'timeout' ) {\n\t\t\t\t\t\t\tthis.dispatch( receiveError( action.event + ' request failed: ' + e.message ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\treturn promiseRace;\n\t\t\t},\n\t\t\t( e ) => {\n\t\t\t\tthis.dispatch( receiveError( 'failed to send ' + action.event + ': ' + e ) );\n\t\t\t\t// so we can relay the error message, for testing purposes\n\t\t\t\treturn Promise.reject( e );\n\t\t\t}\n\t\t);\n\t}\n}\n\nexport default () => new Connection();\n"],"names":["debug","debugFactory","Connection","init","dispatch","auth","this","openSocket","Promise","resolve","reject","then","url","user","signer_user_id","jwt","locale","groups","skills","geoLocation","socket","IO","transports","buildConnection","once","receiveConnect","on","handler","receiveToken","receiveInit","requestTranscript","close","receiveUnauthorized","reason","receiveDisconnect","receiveReconnecting","status","receiveStatus","accept","receiveAccept","receiveLocalizedSupport","message","receiveMessage","receiveMessageOptimistic","receiveMessageUpdate","io","opts","catch","e","send","action","emit","event","payload","receiveError","request","timeout","promiseRace","race","result","Error","setTimeout","callback"],"sourceRoot":""}